# ============================================================
# cleanup-old-runs.yml
# Beh√§lt nur die letzten 5 completed Runs von main.yml
# L√∂scht alle √§lteren automatisch nach jedem neuen Run
# ============================================================
name: Cleanup Old Workflow Runs

on:
  # Nach jedem Abschluss von main.yml aufrufen
  workflow_run:
    workflows: ["TS3 Status Update"]   # muss dem "name:" in main.yml entsprechen
    types: [completed]

  # Auch manuell ausl√∂sbar (f√ºr einmalige Bereinigung)
  workflow_dispatch:
    inputs:
      keep:
        description: 'Wie viele Runs behalten (Standard: 5)'
        required: false
        default: '5'
      dry_run:
        description: 'Nur anzeigen, nicht l√∂schen (true/false)'
        required: false
        default: 'false'

jobs:
  cleanup:
    name: Keep only last ${{ inputs.keep || 5 }} runs
    runs-on: ubuntu-latest
    permissions:
      actions: write   # Ben√∂tigt um Runs zu l√∂schen

    steps:
      - name: Cleanup old runs of main.yml
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const KEEP        = parseInt(core.getInput('keep') || '${{ inputs.keep || 5 }}');
            const DRY_RUN     = '${{ inputs.dry_run || 'false' }}' === 'true';
            const WORKFLOW    = 'main.yml';
            const owner       = context.repo.owner;
            const repo        = context.repo.repo;

            core.info(`Konfiguration: KEEP=${KEEP}, DRY_RUN=${DRY_RUN}`);
            core.info(`Repository: ${owner}/${repo}, Workflow: ${WORKFLOW}`);

            // Alle Runs f√ºr main.yml abrufen (nur completed, neueste zuerst)
            let allRuns = [];
            let page    = 1;

            while (true) {
              const response = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: WORKFLOW,
                status:      'completed',
                per_page:    100,
                page:        page,
              });

              const runs = response.data.workflow_runs;
              if (runs.length === 0) break;

              allRuns = allRuns.concat(runs);
              if (runs.length < 100) break;
              page++;
            }

            // Nach Datum sortieren ‚Äì neueste zuerst
            allRuns.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            core.info(`Gefundene Runs insgesamt: ${allRuns.length}`);
            core.info(`Behalte die neuesten ${KEEP} Runs`);

            // Runs die gel√∂scht werden sollen (alles nach Index KEEP)
            const toDelete = allRuns.slice(KEEP);

            if (toDelete.length === 0) {
              core.info('‚úÖ Nichts zu l√∂schen ‚Äì weniger als oder genau ${KEEP} Runs vorhanden.');
              return;
            }

            core.info(`Zu l√∂schende Runs: ${toDelete.length}`);

            let deleted  = 0;
            let failed   = 0;
            let skipped  = 0;

            for (const run of toDelete) {
              const runInfo = `Run #${run.run_number} (ID: ${run.id}) vom ${run.created_at} ‚Äì ${run.conclusion}`;

              // Sicherheitspr√ºfung: Laufende Runs niemals l√∂schen
              if (run.status !== 'completed') {
                core.warning(`‚è≠Ô∏è √úbersprungen (nicht abgeschlossen): ${runInfo}`);
                skipped++;
                continue;
              }

              if (DRY_RUN) {
                core.info(`[DRY-RUN] W√ºrde l√∂schen: ${runInfo}`);
                deleted++;
                continue;
              }

              try {
                await github.rest.actions.deleteWorkflowRun({
                  owner,
                  repo,
                  run_id: run.id,
                });
                core.info(`üóëÔ∏è Gel√∂scht: ${runInfo}`);
                deleted++;

                // Rate-Limit schonen: kurze Pause zwischen L√∂schanfragen
                await new Promise(resolve => setTimeout(resolve, 300));

              } catch (error) {
                core.warning(`‚ùå Fehler beim L√∂schen von ${runInfo}: ${error.message}`);
                failed++;
              }
            }

            // Zusammenfassung
            core.info('');
            core.info('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            core.info(`‚úÖ Ergebnis:`);
            core.info(`   Gel√∂scht:     ${deleted}`);
            core.info(`   √úbersprungen: ${skipped}`);
            core.info(`   Fehler:       ${failed}`);
            core.info(`   Verbleibend:  ${Math.min(allRuns.length, KEEP)} Runs`);
            core.info('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            if (failed > 0) {
              core.setFailed(`${failed} Run(s) konnten nicht gel√∂scht werden.`);
            }
